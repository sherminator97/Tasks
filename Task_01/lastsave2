
R version 3.6.2 (2019-12-12) -- "Dark and Stormy Night"
Copyright (C) 2019 The R Foundation for Statistical Computing
Platform: x86_64-w64-mingw32/x64 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

[Previously saved workspace restored]

> library (swirl)

| Hi! I see that you have some variables saved in your workspace. To keep
| things running smoothly, I recommend you clean up before starting swirl.

| Type ls() to see a list of the variables in your workspace. Then, type
| rm(list=ls()) to clear your workspace.

| Type swirl() when you are ready to begin.

> swirl ()

| Welcome to swirl! Please sign in. If you've been here before, use the same
| name as you did then. If you are new, call yourself something unique.

What shall I call you? Sherwin Miller

| Please choose a course, or type 0 to exit swirl.

1: R Programming
2: Take me to the swirl course repository!

Selection: 1

| Please choose a lesson, or type 0 to return to course menu.

 1: Basic Building Blocks      2: Workspace and Files     
 3: Sequences of Numbers       4: Vectors                 
 5: Missing Values             6: Subsetting Vectors      
 7: Matrices and Data Frames   8: Logic                   
 9: Functions                 10: lapply and sapply       
11: vapply and tapply         12: Looking at Data         
13: Simulation                14: Dates and Times         
15: Base Graphics             

Selection: 5

  |                                                                              |                                                                      |   0%

| Missing values play an important role in statistics and data analysis. Often,
| missing values must not be ignored, but rather they should be carefully
| studied to see if there's an underlying pattern or cause for their
| missingness.

...

  |                                                                              |====                                                                  |   5%
| In R, NA is used to represent any value that is 'not available' or 'missing'
| (in the statistical sense). In this lesson, we'll explore missing values
| further.

...

  |                                                                              |=======                                                               |  10%
| Any operation involving NA generally yields NA as the result. To illustrate,
| let's create a vector c(44, NA, 5, NA) and assign it to a variable x.

> x <- c(44, NA, 5, NA)

| You're the best!

  |                                                                              |===========                                                           |  15%
| Now, let's multiply x by 3.

> x * 3
[1] 132  NA  15  NA

| All that hard work is paying off!

  |                                                                              |==============                                                        |  20%
| Notice that the elements of the resulting vector that correspond with the NA
| values in x are also NA.

...

  |                                                                              |==================                                                    |  25%
| To make things a little more interesting, lets create a vector containing
| 1000 draws from a standard normal distribution with y <- rnorm(1000).

> y <- rnorm(1000)

| Nice work!

  |                                                                              |=====================                                                 |  30%
| Next, let's create a vector containing 1000 NAs with z <- rep(NA, 1000).

> z <- rep(NA, 1000)

| You're the best!

  |                                                                              |=========================                                             |  35%
| Finally, let's select 100 elements at random from these 2000 values
| (combining y and z) such that we don't know how many NAs we'll wind up with
| or what positions they'll occupy in our final vector -- my_data <-
| sample(c(y, z), 100).

> my_data <- sample(c(y, z), 100)

| That's the answer I was looking for.

  |                                                                              |============================                                          |  40%
| Let's first ask the question of where our NAs are located in our data. The
| is.na() function tells us whether each element of a vector is NA. Call
| is.na() on my_data and assign the result to my_na.

> my_na <- is.na(my_data)

| That's a job well done!

  |                                                                              |================================                                      |  45%
| Now, print my_na to see what you came up with.

> my_na
  [1]  TRUE  TRUE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE
 [13] FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE
 [25]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE FALSE  TRUE FALSE
 [37]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE
 [49] FALSE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE
 [61] FALSE FALSE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE
 [73] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE
 [85] FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE
 [97] FALSE FALSE FALSE  TRUE

| You got it!

  |                                                                              |===================================                                   |  50%
| Everywhere you see a TRUE, you know the corresponding element of my_data is
| NA. Likewise, everywhere you see a FALSE, you know the corresponding element
| of my_data is one of our random draws from the standard normal distribution.

...

  |                                                                              |======================================                                |  55%
| In our previous discussion of logical operators, we introduced the `==`
| operator as a method of testing for equality between two objects. So, you
| might think the expression my_data == NA yields the same results as is.na().
| Give it a try.

> my_data == NA
  [1] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA
 [26] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA
 [51] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA
 [76] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA

| You got it right!

  |                                                                              |==========================================                            |  60%
| The reason you got a vector of all NAs is that NA is not really a value, but
| just a placeholder for a quantity that is not available. Therefore the
| logical expression is incomplete and R has no choice but to return a vector
| of the same length as my_data that contains all NAs.

...

  |                                                                              |==============================================                        |  65%
| Don't worry if that's a little confusing. The key takeaway is to be cautious
| when using logical expressions anytime NAs might creep in, since a single NA
| value can derail the entire thing.

...

  |                                                                              |=================================================                     |  70%
| So, back to the task at hand. Now that we have a vector, my_na, that has a
| TRUE for every NA and FALSE for every numeric value, we can compute the total
| number of NAs in our data.

...

  |                                                                              |====================================================                  |  75%
| The trick is to recognize that underneath the surface, R represents TRUE as
| the number 1 and FALSE as the number 0. Therefore, if we take the sum of a
| bunch of TRUEs and FALSEs, we get the total number of TRUEs.

...

  |                                                                              |========================================================              |  80%
| Let's give that a try here. Call the sum() function on my_na to count the
| total number of TRUEs in my_na, and thus the total number of NAs in my_data.
| Don't assign the result to a new variable.

> sum(my_na) 
[1] 58

| That's a job well done!

  |                                                                              |============================================================          |  85%
| Pretty cool, huh? Finally, let's take a look at the data to convince
| ourselves that everything 'adds up'. Print my_data to the console.

> my_data
  [1]           NA           NA  0.707363311           NA           NA
  [6]  0.140837221  0.842953236  1.313826608 -1.405152802           NA
 [11]           NA           NA  2.460986972  0.486293196  1.005962039
 [16]           NA  0.325120564           NA  0.669114781           NA
 [21]  0.361520577  0.241251782  0.727198562  0.158848218           NA
 [26]           NA           NA           NA           NA           NA
 [31] -0.125900745           NA           NA -0.667328287           NA
 [36] -0.627131026           NA           NA           NA           NA
 [41]           NA           NA           NA           NA           NA
 [46]           NA           NA  1.035795166  0.165443865           NA
 [51]  0.323266804           NA           NA           NA           NA
 [56]           NA -0.795253349 -0.481041166  1.904650747 -1.707172375
 [61]  0.473407298 -0.194978760           NA -2.318750049           NA
 [66]           NA           NA           NA           NA -0.112353109
 [71] -0.213630767 -2.431815516 -0.469808600           NA           NA
 [76]           NA           NA           NA           NA  0.737808269
 [81]           NA           NA           NA           NA  1.342700147
 [86] -0.544694187 -0.490103034 -0.235985885  0.262131591           NA
 [91]           NA           NA  1.388522497           NA -1.788162247
 [96]           NA -0.702111641  0.005800106  0.590500959           NA

| Perseverance, that's the answer.

  |                                                                              |===============================================================       |  90%
| Now that we've got NAs down pat, let's look at a second type of missing value
| -- NaN, which stands for 'not a number'. To generate NaN, try dividing (using
| a forward slash) 0 by 0 now.

> 0/0
[1] NaN

| You nailed it! Good job!

  |                                                                              |==================================================================    |  95%
| Let's do one more, just for fun. In R, Inf stands for infinity. What happens
| if you subtract Inf from Inf?

> inf-inf
Error: object 'inf' not found
> Inf-Inf
[1] NaN

| You are doing so well!

  |                                                                              |======================================================================| 100%
| Would you like to receive credit for completing this course on Coursera.org?

1: Yes
2: No

Selection: 2

| You nailed it! Good job!

| You've reached the end of this lesson! Returning to the main menu...

| Please choose a course, or type 0 to exit swirl.

1: R Programming
2: Take me to the swirl course repository!

Selection: 1

| Please choose a lesson, or type 0 to return to course menu.

 1: Basic Building Blocks      2: Workspace and Files     
 3: Sequences of Numbers       4: Vectors                 
 5: Missing Values             6: Subsetting Vectors      
 7: Matrices and Data Frames   8: Logic                   
 9: Functions                 10: lapply and sapply       
11: vapply and tapply         12: Looking at Data         
13: Simulation                14: Dates and Times         
15: Base Graphics             

Selection: 6

  |                                                                              |                                                                      |   0%

| In this lesson, we'll see how to extract elements from a vector based on some
| conditions that we specify.

...

  |                                                                              |==                                                                    |   3%
| For example, we may only be interested in the first 20 elements of a vector,
| or only the elements that are not NA, or only those that are positive or
| correspond to a specific variable of interest. By the end of this lesson,
| you'll know how to handle each of these scenarios.

...

  |                                                                              |====                                                                  |   5%
| I've created for you a vector called x that contains a random ordering of 20
| numbers (from a standard normal distribution) and 20 NAs. Type x now to see
| what it looks like.

> x
 [1]         NA         NA         NA -2.4953154         NA  0.6432508
 [7]         NA         NA  0.1019905         NA         NA  0.7981794
[13] -0.6060349 -1.8632107 -0.3304697         NA         NA  0.1984686
[19] -0.5196755  0.1088269         NA -0.4520570         NA -2.2581537
[25]         NA         NA  0.6299203         NA -1.4656436         NA
[31]  0.8775085 -0.6167873         NA         NA         NA  1.8247025
[37]  0.7056609  1.0345930  0.5900267         NA

| Your dedication is inspiring!

  |                                                                              |=====                                                                 |   8%
| The way you tell R that you want to select some particular elements (i.e. a
| 'subset') from a vector is by placing an 'index vector' in square brackets
| immediately following the name of the vector.

...

  |                                                                              |=======                                                               |  10%
| For a simple example, try x[1:10] to view the first ten elements of x.

> x[1:10]
 [1]         NA         NA         NA -2.4953154         NA  0.6432508
 [7]         NA         NA  0.1019905         NA

| You are amazing!

  |                                                                              |=========                                                             |  13%
| Index vectors come in four different flavors -- logical vectors, vectors of
| positive integers, vectors of negative integers, and vectors of character
| strings -- each of which we'll cover in this lesson.

...

  |                                                                              |===========                                                           |  15%
| Let's start by indexing with logical vectors. One common scenario when
| working with real-world data is that we want to extract all elements of a
| vector that are not NA (i.e. missing data). Recall that is.na(x) yields a
| vector of logical values the same length as x, with TRUEs corresponding to NA
| values in x and FALSEs corresponding to non-NA values in x.

...

  |                                                                              |=============                                                         |  18%
| What do you think x[is.na(x)] will give you?

1: A vector of all NAs
2: A vector with no NAs
3: A vector of TRUEs and FALSEs
4: A vector of length 0

Selection: 4

| That's not exactly what I'm looking for. Try again.

| Remember that is.na(x) tells us where the NAs are in a vector. So if we
| subset x based on that, what do you expect to happen?

1: A vector with no NAs
2: A vector of length 0
3: A vector of TRUEs and FALSEs
4: A vector of all NAs

Selection: 3

| One more time. You can do it!

| Remember that is.na(x) tells us where the NAs are in a vector. So if we
| subset x based on that, what do you expect to happen?

1: A vector of all NAs
2: A vector with no NAs
3: A vector of TRUEs and FALSEs
4: A vector of length 0

Selection: 1

| Your dedication is inspiring!

  |                                                                              |==============                                                        |  21%
| Prove it to yourself by typing x[is.na(x)].

> x[is.na(x)]
 [1] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA

| You're the best!

  |                                                                              |================                                                      |  23%
| Recall that `!` gives us the negation of a logical expression, so !is.na(x)
| can be read as 'is not NA'. Therefore, if we want to create a vector called y
| that contains all of the non-NA values from x, we can use y <- x[!is.na(x)].
| Give it a try.

> y <- x[!is.na(x)]

| Excellent job!

  |                                                                              |==================                                                    |  26%
| Print y to the console.

> y
 [1] -2.4953154  0.6432508  0.1019905  0.7981794 -0.6060349 -1.8632107
 [7] -0.3304697  0.1984686 -0.5196755  0.1088269 -0.4520570 -2.2581537
[13]  0.6299203 -1.4656436  0.8775085 -0.6167873  1.8247025  0.7056609
[19]  1.0345930  0.5900267

| You're the best!

  |                                                                              |====================                                                  |  28%
| Now that we've isolated the non-missing values of x and put them in y, we can
| subset y as we please.

...

  |                                                                              |======================                                                |  31%
| Recall that the expression y > 0 will give us a vector of logical values the
| same length as y, with TRUEs corresponding to values of y that are greater
| than zero and FALSEs corresponding to values of y that are less than or equal
| to zero. What do you think y[y > 0] will give you?

1: A vector of length 0
2: A vector of all the negative elements of y
3: A vector of all NAs
4: A vector of all the positive elements of y
5: A vector of TRUEs and FALSEs

Selection: 4

| Keep up the great work!

  |                                                                              |=======================                                               |  33%
| Type y[y > 0] to see that we get all of the positive elements of y, which are
| also the positive elements of our original vector x.

> y[y > 0]
 [1] 0.6432508 0.1019905 0.7981794 0.1984686 0.1088269 0.6299203 0.8775085
 [8] 1.8247025 0.7056609 1.0345930 0.5900267

| Keep up the great work!

  |                                                                              |=========================                                             |  36%
| You might wonder why we didn't just start with x[x > 0] to isolate the
| positive elements of x. Try that now to see why.

> x[x > 0]
 [1]        NA        NA        NA        NA 0.6432508        NA        NA
 [8] 0.1019905        NA        NA 0.7981794        NA        NA 0.1984686
[15] 0.1088269        NA        NA        NA        NA 0.6299203        NA
[22]        NA 0.8775085        NA        NA        NA 1.8247025 0.7056609
[29] 1.0345930 0.5900267        NA

| You are quite good my friend!

  |                                                                              |===========================                                           |  38%
| Since NA is not a value, but rather a placeholder for an unknown quantity,
| the expression NA > 0 evaluates to NA. Hence we get a bunch of NAs mixed in
| with our positive numbers when we do this.

...

  |                                                                              |=============================                                         |  41%
| Combining our knowledge of logical operators with our new knowledge of
| subsetting, we could do this -- x[!is.na(x) & x > 0]. Try it out.

> x[!is.na(x) & x > 0]
 [1] 0.6432508 0.1019905 0.7981794 0.1984686 0.1088269 0.6299203 0.8775085
 [8] 1.8247025 0.7056609 1.0345930 0.5900267

| You are really on a roll!

  |                                                                              |===============================                                       |  44%
| In this case, we request only values of x that are both non-missing AND
| greater than zero.

...

  |                                                                              |================================                                      |  46%
| I've already shown you how to subset just the first ten values of x using
| x[1:10]. In this case, we're providing a vector of positive integers inside
| of the square brackets, which tells R to return only the elements of x
| numbered 1 through 10.

...

  |                                                                              |==================================                                    |  49%
| Many programming languages use what's called 'zero-based indexing', which
| means that the first element of a vector is considered element 0. R uses
| 'one-based indexing', which (you guessed it!) means the first element of a
| vector is considered element 1.

...

  |                                                                              |====================================                                  |  51%
| Can you figure out how we'd subset the 3rd, 5th, and 7th elements of x? Hint
| -- Use the c() function to specify the element numbers as a numeric vector.

> c(x(3, 5, 7))
Error in x(3, 5, 7) : could not find function "x"
> c(3, 5, 7)
[1] 3 5 7

| Keep trying! Or, type info() for more options.

| Create a vector of indexes with c(3, 5, 7), then put that inside of the
| square brackets.

> c[(3, 5, 7)]
Error: unexpected ',' in "c[(3,"
> [c(3, 5, 7)]
Error: unexpected '[' in "["
> [c(3, 5, 7),]
Error: unexpected '[' in "["
> x[c(3, 5, 7)]
[1] NA NA NA

| You're the best!

  |                                                                              |======================================                                |  54%
| It's important that when using integer vectors to subset our vector x, we
| stick with the set of indexes {1, 2, ..., 40} since x only has 40 elements.
| What happens if we ask for the zeroth element of x (i.e. x[0])? Give it a
| try.

> x[0]
numeric(0)

| Excellent work!

  |                                                                              |=======================================                               |  56%
| As you might expect, we get nothing useful. Unfortunately, R doesn't prevent
| us from doing this. What if we ask for the 3000th element of x? Try it out.

> x[3000]
[1] NA

| Your dedication is inspiring!

  |                                                                              |=========================================                             |  59%
| Again, nothing useful, but R doesn't prevent us from asking for it. This
| should be a cautionary tale. You should always make sure that what you are
| asking for is within the bounds of the vector you're working with.

...

  |                                                                              |===========================================                           |  62%
| What if we're interested in all elements of x EXCEPT the 2nd and 10th? It
| would be pretty tedious to construct a vector containing all numbers 1
| through 40 EXCEPT 2 and 10.

...

  |                                                                              |=============================================                         |  64%
| Luckily, R accepts negative integer indexes. Whereas x[c(2, 10)] gives us
| ONLY the 2nd and 10th elements of x, x[c(-2, -10)] gives us all elements of x
| EXCEPT for the 2nd and 10 elements.  Try x[c(-2, -10)] now to see this.

> x[c(-2, -10)]
 [1]         NA         NA -2.4953154         NA  0.6432508         NA
 [7]         NA  0.1019905         NA  0.7981794 -0.6060349 -1.8632107
[13] -0.3304697         NA         NA  0.1984686 -0.5196755  0.1088269
[19]         NA -0.4520570         NA -2.2581537         NA         NA
[25]  0.6299203         NA -1.4656436         NA  0.8775085 -0.6167873
[31]         NA         NA         NA  1.8247025  0.7056609  1.0345930
[37]  0.5900267         NA

| Excellent work!

  |                                                                              |===============================================                       |  67%
| A shorthand way of specifying multiple negative numbers is to put the
| negative sign out in front of the vector of positive numbers. Type x[-c(2,
| 10)] to get the exact same result.

> x[-c(2, 10)]
 [1]         NA         NA -2.4953154         NA  0.6432508         NA
 [7]         NA  0.1019905         NA  0.7981794 -0.6060349 -1.8632107
[13] -0.3304697         NA         NA  0.1984686 -0.5196755  0.1088269
[19]         NA -0.4520570         NA -2.2581537         NA         NA
[25]  0.6299203         NA -1.4656436         NA  0.8775085 -0.6167873
[31]         NA         NA         NA  1.8247025  0.7056609  1.0345930
[37]  0.5900267         NA

| Your dedication is inspiring!

  |                                                                              |================================================                      |  69%
| So far, we've covered three types of index vectors -- logical, positive
| integer, and negative integer. The only remaining type requires us to
| introduce the concept of 'named' elements.

...

  |                                                                              |==================================================                    |  72%
| Create a numeric vector with three named elements using vect <- c(foo = 11,
| bar = 2, norf = NA).

> vect <- c(foo = 11, bar = 2, norf = NA)

| You are amazing!

  |                                                                              |====================================================                  |  74%
| When we print vect to the console, you'll see that each element has a name.
| Try it out.

> vect
 foo  bar norf 
  11    2   NA 

| You are amazing!

  |                                                                              |======================================================                |  77%
| We can also get the names of vect by passing vect as an argument to the
| names() function. Give that a try.

> names(vect)
[1] "foo"  "bar"  "norf"

| All that hard work is paying off!

  |                                                                              |========================================================              |  79%
| Alternatively, we can create an unnamed vector vect2 with c(11, 2, NA). Do
| that now.

> vect2 <- c(11, 2, NA)

| Your dedication is inspiring!

  |                                                                              |=========================================================             |  82%
| Then, we can add the `names` attribute to vect2 after the fact with
| names(vect2) <- c("foo", "bar", "norf"). Go ahead.

> names(vect2) <- c("foo", "bar", "norf")

| You nailed it! Good job!

  |                                                                              |===========================================================           |  85%
| Now, let's check that vect and vect2 are the same by passing them as
| arguments to the identical() function.

> identical(vect, vect2)
[1] TRUE

| You're the best!

  |                                                                              |=============================================================         |  87%
| Indeed, vect and vect2 are identical named vectors.

...

  |                                                                              |===============================================================       |  90%
| Now, back to the matter of subsetting a vector by named elements. Which of
| the following commands do you think would give us the second element of vect?

1: vect[bar]
2: vect["2"]
3: vect["bar"]

Selection: 3

| Keep up the great work!

  |                                                                              |=================================================================     |  92%
| Now, try it out.

> vect["bar"]
bar 
  2 

| That's correct!

  |                                                                              |==================================================================    |  95%
| Likewise, we can specify a vector of names with vect[c("foo", "bar")]. Try it
| out.

> vect[c("foo", "bar")]
foo bar 
 11   2 

| You got it!

  |                                                                              |====================================================================  |  97%
| Now you know all four methods of subsetting data from vectors. Different
| approaches are best in different scenarios and when in doubt, try it out!

...

  |                                                                              |======================================================================| 100%
| Would you like to receive credit for completing this course on Coursera.org?

1: Yes
2: No

Selection: 2

| You are really on a roll!

| You've reached the end of this lesson! Returning to the main menu...

| Please choose a course, or type 0 to exit swirl.

1: R Programming
2: Take me to the swirl course repository!

Selection: 1

| Please choose a lesson, or type 0 to return to course menu.

 1: Basic Building Blocks      2: Workspace and Files     
 3: Sequences of Numbers       4: Vectors                 
 5: Missing Values             6: Subsetting Vectors      
 7: Matrices and Data Frames   8: Logic                   
 9: Functions                 10: lapply and sapply       
11: vapply and tapply         12: Looking at Data         
13: Simulation                14: Dates and Times         
15: Base Graphics             

Selection: 7

  |                                                                              |                                                                      |   0%

| In this lesson, we'll cover matrices and data frames. Both represent
| 'rectangular' data types, meaning that they are used to store tabular data,
| with rows and columns.

...

  |                                                                              |==                                                                    |   3%
| The main difference, as you'll see, is that matrices can only contain a
| single class of data, while data frames can consist of many different classes
| of data.

...

  |                                                                              |====                                                                  |   6%
| Let's create a vector containing the numbers 1 through 20 using the `:`
| operator. Store the result in a variable called my_vector.

> my_vector <- 1:20

| You are amazing!

  |                                                                              |======                                                                |   8%
| View the contents of the vector you just created.

> my_vector
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20

| You nailed it! Good job!

  |                                                                              |========                                                              |  11%
| The dim() function tells us the 'dimensions' of an object. What happens if we
| do dim(my_vector)? Give it a try.

> dim(my_vector)
NULL

| Nice work!

  |                                                                              |==========                                                            |  14%
| Clearly, that's not very helpful! Since my_vector is a vector, it doesn't
| have a `dim` attribute (so it's just NULL), but we can find its length using
| the length() function. Try that now.

> length(my_vector)
[1] 20

| Your dedication is inspiring!

  |                                                                              |============                                                          |  17%
| Ah! That's what we wanted. But, what happens if we give my_vector a `dim`
| attribute? Let's give it a try. Type dim(my_vector) <- c(4, 5).

> dim(my_vector) <- c(4,5)

| That's a job well done!

  |                                                                              |==============                                                        |  19%
| It's okay if that last command seemed a little strange to you. It should! The
| dim() function allows you to get OR set the `dim` attribute for an R object.
| In this case, we assigned the value c(4, 5) to the `dim` attribute of
| my_vector.

...

  |                                                                              |================                                                      |  22%
| Use dim(my_vector) to confirm that we've set the `dim` attribute correctly.

> dim(my_vector)
[1] 4 5

| You got it!

  |                                                                              |==================                                                    |  25%
| Another way to see this is by calling the attributes() function on my_vector.
| Try it now.

> attributes(my_vector)
$dim
[1] 4 5


| You got it right!

  |                                                                              |===================                                                   |  28%
| Just like in math class, when dealing with a 2-dimensional object (think
| rectangular table), the first number is the number of rows and the second is
| the number of columns. Therefore, we just gave my_vector 4 rows and 5
| columns.

...

  |                                                                              |=====================                                                 |  31%
| But, wait! That doesn't sound like a vector any more. Well, it's not. Now
| it's a matrix. View the contents of my_vector now to see what it looks like.

> my_vector
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    5    9   13   17
[2,]    2    6   10   14   18
[3,]    3    7   11   15   19
[4,]    4    8   12   16   20

| You got it right!

  |                                                                              |=======================                                               |  33%
| Now, let's confirm it's actually a matrix by using the class() function. Type
| class(my_vector) to see what I mean.

> class(my_vector)
[1] "matrix"

| All that hard work is paying off!

  |                                                                              |=========================                                             |  36%
| Sure enough, my_vector is now a matrix. We should store it in a new variable
| that helps us remember what it is. Store the value of my_vector in a new
| variable called my_matrix.

> my_matrix <- my_vector

| All that hard work is paying off!

  |                                                                              |===========================                                           |  39%
| The example that we've used so far was meant to illustrate the point that a
| matrix is simply an atomic vector with a dimension attribute. A more direct
| method of creating the same matrix uses the matrix() function.

...

  |                                                                              |=============================                                         |  42%
| Bring up the help file for the matrix() function now using the `?` function.

> ?matrix
starting httpd help server ... done

| That's correct!

  |                                                                              |===============================                                       |  44%
| Now, look at the documentation for the matrix function and see if you can
| figure out how to create a matrix containing the same numbers (1-20) and
| dimensions (4 rows, 5 columns) by calling the matrix() function. Store the
| result in a variable called my_matrix2.

> my_matrix2 <- matrix(1:20 dim(c(4,5))
Error: unexpected symbol in "my_matrix2 <- matrix(1:20 dim"
> my_matrix <- matrix(1:20, nrow = 4, ncol = 5, byrow = FALSE, dimnames = NULL)

| Not quite! Try again. Or, type info() for more options.

| Call the matrix() function with three arguments -- 1:20, the number of rows,
| and the number of columns. Be sure to specify arguments by their proper names
| and store the result in my_matrix2 (not in my_matrix).

> my_matrix <- matrix(1:20, nrow = 4, ncol = 5, byrow = FALSE, dimnames = NULL)

| Not quite, but you're learning! Try again. Or, type info() for more options.

| Call the matrix() function with three arguments -- 1:20, the number of rows,
| and the number of columns. Be sure to specify arguments by their proper names
| and store the result in my_matrix2 (not in my_matrix).

> y_matrix2 <- matrix(1:20, nrow = 4, ncol = 5, byrow = FALSE, dimnames = NULL)

| Not exactly. Give it another go. Or, type info() for more options.

| Call the matrix() function with three arguments -- 1:20, the number of rows,
| and the number of columns. Be sure to specify arguments by their proper names
| and store the result in my_matrix2 (not in my_matrix).

> my_matrix2 <- matrix(1:20, nrow = 4, ncol = 5, byrow = FALSE, dimnames = NULL)

| That's not exactly what I'm looking for. Try again. Or, type info() for more
| options.

| Call the matrix() function with three arguments -- 1:20, the number of rows,
| and the number of columns. Be sure to specify arguments by their proper names
| and store the result in my_matrix2 (not in my_matrix).

> my_matrix2 <- matrix(1:20, nrow = 4, ncol = 5, byrow = FALSE,dimnames = NULL)

| Give it another try. Or, type info() for more options.

| Call the matrix() function with three arguments -- 1:20, the number of rows,
| and the number of columns. Be sure to specify arguments by their proper names
| and store the result in my_matrix2 (not in my_matrix).

> my_matrix2 <- matrix(1:20, nrow = 4, ncol = 5)

| That's not exactly what I'm looking for. Try again. Or, type info() for more
| options.

| Call the matrix() function with three arguments -- 1:20, the number of rows,
| and the number of columns. Be sure to specify arguments by their proper names
| and store the result in my_matrix2 (not in my_matrix).

> my_matrix2 <- matrix(1:20, nrow=4, ncol=5)

| You almost had it, but not quite. Try again. Or, type info() for more
| options.

| Call the matrix() function with three arguments -- 1:20, the number of rows,
| and the number of columns. Be sure to specify arguments by their proper names
| and store the result in my_matrix2 (not in my_matrix).

> my_matrix2 <- matrix(1:20, nrow = 4, ncol = 5)

| Try again. Getting it right on the first try is boring anyway! Or, type
| info() for more options.

| Call the matrix() function with three arguments -- 1:20, the number of rows,
| and the number of columns. Be sure to specify arguments by their proper names
| and store the result in my_matrix2 (not in my_matrix).

> my_matrix2 <- matrix(1:20,nrow = 4,ncol = 5)

| That's not exactly what I'm looking for. Try again. Or, type info() for more
| options.

| Call the matrix() function with three arguments -- 1:20, the number of rows,
| and the number of columns. Be sure to specify arguments by their proper names
| and store the result in my_matrix2 (not in my_matrix).

> my_matrix2 <- matrix(1:20,nrow = 4,ncol = 5, byrow = FALSE)

| Try again. Getting it right on the first try is boring anyway! Or, type
| info() for more options.

| Call the matrix() function with three arguments -- 1:20, the number of rows,
| and the number of columns. Be sure to specify arguments by their proper names
| and store the result in my_matrix2 (not in my_matrix).

> my_matrix2 <- matrix(1:20, nrow = 4, ncol = 5, byrow = FALSE)

| Give it another try. Or, type info() for more options.

| Call the matrix() function with three arguments -- 1:20, the number of rows,
| and the number of columns. Be sure to specify arguments by their proper names
| and store the result in my_matrix2 (not in my_matrix).

> my_matrix2 <- matrix(data = 1:20, nrow = 4, ncol = 5, byrow = FALSE)

| Not quite, but you're learning! Try again. Or, type info() for more options.

| Call the matrix() function with three arguments -- 1:20, the number of rows,
| and the number of columns. Be sure to specify arguments by their proper names
| and store the result in my_matrix2 (not in my_matrix).

> my_matrix2 <- matrix(data = 1:20, nrow = 4, ncol = 5)

| You almost had it, but not quite. Try again. Or, type info() for more
| options.

| Call the matrix() function with three arguments -- 1:20, the number of rows,
| and the number of columns. Be sure to specify arguments by their proper names
| and store the result in my_matrix2 (not in my_matrix).

> my_matrix2 <- matrix(1:20, nrow=4, ncol=5)

| One more time. You can do it! Or, type info() for more options.

| Call the matrix() function with three arguments -- 1:20, the number of rows,
| and the number of columns. Be sure to specify arguments by their proper names
| and store the result in my_matrix2 (not in my_matrix).

> my_matrix2 <- matrix(1:20, nrow=4, ncol=5)

| That's not the answer I was looking for, but try again. Or, type info() for
| more options.

| Call the matrix() function with three arguments -- 1:20, the number of rows,
| and the number of columns. Be sure to specify arguments by their proper names
| and store the result in my_matrix2 (not in my_matrix).

> my_matrix2 <-matrix(1:20, nrow = 4, ncol = 5, byrow = FALSE,dimnames = NULL)

| You almost had it, but not quite. Try again. Or, type info() for more
| options.

| Call the matrix() function with three arguments -- 1:20, the number of rows,
| and the number of columns. Be sure to specify arguments by their proper names
| and store the result in my_matrix2 (not in my_matrix).

> my_matrix2 <-matrix(data = 1:20, nrow = 4, ncol = 5, byrow = FALSE,dimnames = NULL)

| Not quite, but you're learning! Try again. Or, type info() for more options.

| Call the matrix() function with three arguments -- 1:20, the number of rows,
| and the number of columns. Be sure to specify arguments by their proper names
| and store the result in my_matrix2 (not in my_matrix).

> my_matrix2 <-matrix(data = 1:20, nrow = 4, ncol = 5, byrow = FALSE, dimnames = NULL)

| That's not the answer I was looking for, but try again. Or, type info() for
| more options.

| Call the matrix() function with three arguments -- 1:20, the number of rows,
| and the number of columns. Be sure to specify arguments by their proper names
| and store the result in my_matrix2 (not in my_matrix).

> my_matrix2 <- matrix(data = 1:20, nrow = 4, ncol = 5, byrow = FALSE, dimnames = NULL)

| One more time. You can do it! Or, type info() for more options.

| Call the matrix() function with three arguments -- 1:20, the number of rows,
| and the number of columns. Be sure to specify arguments by their proper names
| and store the result in my_matrix2 (not in my_matrix).

> ?matrix
> my_matrix2 <- matrix(data = NA, nrow = 1, ncol = 1, byrow = FALSE, dimnames = NULL)

| Not exactly. Give it another go. Or, type info() for more options.

| Call the matrix() function with three arguments -- 1:20, the number of rows,
| and the number of columns. Be sure to specify arguments by their proper names
| and store the result in my_matrix2 (not in my_matrix).

> matrix(data = NA, nrow = 1, ncol = 1, byrow = FALSE, dimnames = NULL)
     [,1]
[1,]   NA

| Almost! Try again. Or, type info() for more options.

| Call the matrix() function with three arguments -- 1:20, the number of rows,
| and the number of columns. Be sure to specify arguments by their proper names
| and store the result in my_matrix2 (not in my_matrix).

> my_matrix2 <- matrix(data = 1:20, nrow = 4, ncol = 5, byrow = FALSE, dimnames = NULL)

| Excellent work!

  |                                                                              |=================================                                     |  47%
| Finally, let's confirm that my_matrix and my_matrix2 are actually identical.
| The identical() function will tell us if its first two arguments are the
| same. Try it out.

> identical( my_matrix, my_matrix2)
[1] TRUE

| You got it!

  |                                                                              |===================================                                   |  50%
| Now, imagine that the numbers in our table represent some measurements from a
| clinical experiment, where each row represents one patient and each column
| represents one variable for which measurements were taken.

...

  |                                                                              |=====================================                                 |  53%
| We may want to label the rows, so that we know which numbers belong to each
| patient in the experiment. One way to do this is to add a column to the
| matrix, which contains the names of all four people.

...

  |                                                                              |=======================================                               |  56%
| Let's start by creating a character vector containing the names of our
| patients -- Bill, Gina, Kelly, and Sean. Remember that double quotes tell R
| that something is a character string. Store the result in a variable called
| patients.

> patients <- c("Bill", "Gina", "Kelly", "Sean")

| You got it right!

  |                                                                              |=========================================                             |  58%
| Now we'll use the cbind() function to 'combine columns'. Don't worry about
| storing the result in a new variable. Just call cbind() with two arguments --
| the patients vector and my_matrix.

> cbind(patients, my_matrix)
     patients                       
[1,] "Bill"   "1" "5" "9"  "13" "17"
[2,] "Gina"   "2" "6" "10" "14" "18"
[3,] "Kelly"  "3" "7" "11" "15" "19"
[4,] "Sean"   "4" "8" "12" "16" "20"

| Nice work!

  |                                                                              |===========================================                           |  61%
| Something is fishy about our result! It appears that combining the character
| vector with our matrix of numbers caused everything to be enclosed in double
| quotes. This means we're left with a matrix of character strings, which is no
| good.

...

  |                                                                              |=============================================                         |  64%
| If you remember back to the beginning of this lesson, I told you that
| matrices can only contain ONE class of data. Therefore, when we tried to
| combine a character vector with a numeric matrix, R was forced to 'coerce'
| the numbers to characters, hence the double quotes.

...

  |                                                                              |===============================================                       |  67%
| This is called 'implicit coercion', because we didn't ask for it. It just
| happened. But why didn't R just convert the names of our patients to numbers?
| I'll let you ponder that question on your own.

...

  |                                                                              |=================================================                     |  69%
| So, we're still left with the question of how to include the names of our
| patients in the table without destroying the integrity of our numeric data.
| Try the following -- my_data <- data.frame(patients, my_matrix)

> my_data <- data.frame(patients, my_matrix)

| Nice work!

  |                                                                              |===================================================                   |  72%
| Now view the contents of my_data to see what we've come up with.

> my_data
  patients X1 X2 X3 X4 X5
1     Bill  1  5  9 13 17
2     Gina  2  6 10 14 18
3    Kelly  3  7 11 15 19
4     Sean  4  8 12 16 20

| That's a job well done!

  |                                                                              |====================================================                  |  75%
| It looks like the data.frame() function allowed us to store our character
| vector of names right alongside our matrix of numbers. That's exactly what we
| were hoping for!

...

  |                                                                              |======================================================                |  78%
| Behind the scenes, the data.frame() function takes any number of arguments
| and returns a single object of class `data.frame` that is composed of the
| original objects.

...

  |                                                                              |========================================================              |  81%
| Let's confirm this by calling the class() function on our newly created data
| frame.

> class(data.frame(patients, my_matrix))
[1] "data.frame"

| One more time. You can do it! Or, type info() for more options.

| The class function takes one argument -- the object of which you want to
| determine the class.

> class(data.frame)
[1] "function"

| You're close...I can feel it! Try it again. Or, type info() for more options.

| The class function takes one argument -- the object of which you want to
| determine the class.

> class(data.frame(data.frame))
Error in as.data.frame.default(x[[i]], optional = TRUE) : 
  cannot coerce class "function" to a data.frame
> class(my_data)
[1] "data.frame"

| Great job!

  |                                                                              |==========================================================            |  83%
| It's also possible to assign names to the individual rows and columns of a
| data frame, which presents another possible way of determining which row of
| values in our table belongs to each patient.

...

  |                                                                              |============================================================          |  86%
| However, since we've already solved that problem, let's solve a different
| problem by assigning names to the columns of our data frame so that we know
| what type of measurement each column represents.

...

  |                                                                              |==============================================================        |  89%
| Since we have six columns (including patient names), we'll need to first
| create a vector containing one element for each column. Create a character
| vector called cnames that contains the following values (in order) --
| "patient", "age", "weight", "bp", "rating", "test".

> cnames("patient", "age", "weight", "bp", "rating", "test")
Error in cnames("patient", "age", "weight", "bp", "rating", "test") : 
  could not find function "cnames"
> cnames <-c("patient", "age", "weight", "bp", "rating", "test")

| That's correct!

  |                                                                              |================================================================      |  92%
| Now, use the colnames() function to set the `colnames` attribute for our data
| frame. This is similar to the way we used the dim() function earlier in this
| lesson.

> colnames(cnames)
NULL

| Not quite right, but keep trying. Or, type info() for more options.

| Try colnames(my_data) <- cnames.

> colnames(my_data) <- cnames

| Excellent job!

  |                                                                              |==================================================================    |  94%
| Let's see if that got the job done. Print the contents of my_data.

> my_data
  patient age weight bp rating test
1    Bill   1      5  9     13   17
2    Gina   2      6 10     14   18
3   Kelly   3      7 11     15   19
4    Sean   4      8 12     16   20

| Excellent work!

  |                                                                              |====================================================================  |  97%
| In this lesson, you learned the basics of working with two very important and
| common data structures -- matrices and data frames. There's much more to
| learn and we'll be covering more advanced topics, particularly with respect
| to data frames, in future lessons.

...

  |                                                                              |======================================================================| 100%
| Would you like to receive credit for completing this course on Coursera.org?

1: No
2: Yes

Selection: 1

| Excellent work!

| You've reached the end of this lesson! Returning to the main menu...

| Please choose a course, or type 0 to exit swirl.

1: R Programming
2: Take me to the swirl course repository!

Selection: 1

| Please choose a lesson, or type 0 to return to course menu.

 1: Basic Building Blocks      2: Workspace and Files     
 3: Sequences of Numbers       4: Vectors                 
 5: Missing Values             6: Subsetting Vectors      
 7: Matrices and Data Frames   8: Logic                   
 9: Functions                 10: lapply and sapply       
11: vapply and tapply         12: Looking at Data         
13: Simulation                14: Dates and Times         
15: Base Graphics             

Selection: 8

  |                                                                              |                                                                      |   0%

| This lesson is meant to be a short introduction to logical operations in R.

...

  |                                                                              |=                                                                     |   2%
| There are two logical values in R, also called boolean values. They are TRUE
| and FALSE. In R you can construct logical expressions which will evaluate to
| either TRUE or FALSE.

...

  |                                                                              |===                                                                   |   4%
| Many of the questions in this lesson will involve evaluating logical
| expressions. It may be useful to open up a second R terminal where you can
| experiment with some of these expressions.

...

  |                                                                              |====                                                                  |   6%
| Creating logical expressions requires logical operators. You're probably
| familiar with arithmetic operators like `+`, `-`, `*`, and `/`. The first
| logical operator we are going to discuss is the equality operator,
| represented by two equals signs `==`. Use the equality operator below to find
| out if TRUE is equal to TRUE.

> TRUE==TRUE
[1] TRUE

| Your dedication is inspiring!

  |                                                                              |=====                                                                 |   8%
| Just like arithmetic, logical expressions can be grouped by parenthesis so
| that the entire expression (TRUE == TRUE) == TRUE evaluates to TRUE.

...

  |                                                                              |=======                                                               |  10%
| To test out this property, try evaluating (FALSE == TRUE) == FALSE .

> (FALSE == TRUE) == FALSE
[1] TRUE

| All that hard work is paying off!

  |                                                                              |========                                                              |  12%
| The equality operator can also be used to compare numbers. Use `==` to see if
| 6 is equal to 7.

> 6==7
[1] FALSE

| You are quite good my friend!

  |                                                                              |=========                                                             |  13%
| The previous expression evaluates to FALSE because 6 is less than 7.
| Thankfully, there are inequality operators that allow us to test if a value
| is less than or greater than another value.

...

  |                                                                              |===========                                                           |  15%
| The less than operator `<` tests whether the number on the left side of the
| operator (called the left operand) is less than the number on the right side
| of the operator (called the right operand). Write an expression to test
| whether 6 is less than 7.

> 6<7
[1] TRUE

| Excellent work!

  |                                                                              |============                                                          |  17%
| There is also a less-than-or-equal-to operator `<=` which tests whether the
| left operand is less than or equal to the right operand. Write an expression
| to test whether 10 is less than or equal to 10.

> 10<=10
[1] TRUE

| All that hard work is paying off!

  |                                                                              |=============                                                         |  19%
| Keep in mind that there are the corresponding greater than `>` and
| greater-than-or-equal-to `>=` operators.

...

  |                                                                              |===============                                                       |  21%
| Which of the following evaluates to FALSE?

1: 0 > -36
2: 7 == 7
3: 6 < 8
4: 9 >= 10

Selection: 3

| You're close...I can feel it! Try it again.

| If you need to, you can evaluate each expression in a separate R session to
| find the correct answer.

1: 6 < 8
2: 7 == 7
3: 9 >= 10
4: 0 > -36

Selection: 3

| You're the best!

  |                                                                              |================                                                      |  23%
| Which of the following evaluates to TRUE?

1: 57 < 8
2: 9 >= 10
3: -6 > -7
4: 7 == 9

Selection: 3

| Keep up the great work!

  |                                                                              |==================                                                    |  25%
| The next operator we will discuss is the 'not equals' operator represented by
| `!=`. Not equals tests whether two values are unequal, so TRUE != FALSE
| evaluates to TRUE. Like the equality operator, `!=` can also be used with
| numbers. Try writing an expression to see if 5 is not equal to 7.

> 6!=7
[1] TRUE

| Not quite, but you're learning! Try again. Or, type info() for more options.

| Use the not equals operator and type 5 != 7

> 5!=7
[1] TRUE

| All that practice is paying off!

  |                                                                              |===================                                                   |  27%
| In order to negate boolean expressions you can use the NOT operator. An
| exclamation point `!` will cause !TRUE (say: not true) to evaluate to FALSE
| and !FALSE (say: not false) to evaluate to TRUE. Try using the NOT operator
| and the equals operator to find the opposite of whether 5 is equal to 7.

> 5!=7
[1] TRUE

| You almost had it, but not quite. Try again. Or, type info() for more
| options.

| This expression may be a little tricky, so think about negating the
| expression 5 == 7 (all you need is an exclamation point in front).

> 5!==7
Error: unexpected '=' in "5!=="
> !5==7
[1] TRUE

| Great job!

  |                                                                              |====================                                                  |  29%
| Let's take a moment to review. The equals operator `==` tests whether two
| boolean values or numbers are equal, the not equals operator `!=` tests
| whether two boolean values or numbers are unequal, and the NOT operator `!`
| negates logical expressions so that TRUE expressions become FALSE and FALSE
| expressions become TRUE.

...

  |                                                                              |======================                                                |  31%
| Which of the following evaluates to FALSE?

1: !(0 >= -1)
2: 9 < 10
3: !FALSE
4: 7 != 8

Selection: 
Enter an item from the menu, or 0 to exit
Selection:  
Enter an item from the menu, or 0 to exit
Selection: 1

| That's correct!

  |                                                                              |=======================                                               |  33%
| What do you think the following expression will evaluate to?: (TRUE != FALSE)
| == !(6 == 7)

1: FALSE
2: %>%
3: TRUE
4: Can there be objective truth when programming?

Selection: 4

| That's not the answer I was looking for, but try again.

| Try to evaluate each expression in isolation and build up an answer.

1: FALSE
2: TRUE
3: %>%
4: Can there be objective truth when programming?

Selection: 2

| You are quite good my friend!

  |                                                                              |========================                                              |  35%
| At some point you may need to examine relationships between multiple logical
| expressions. This is where the AND operator and the OR operator come in.

...

  |                                                                              |==========================                                            |  37%
| Let's look at how the AND operator works. There are two AND operators in R,
| `&` and `&&`. Both operators work similarly, if the right and left operands
| of AND are both TRUE the entire expression is TRUE, otherwise it is FALSE.
| For example, TRUE & TRUE evaluates to TRUE. Try typing FALSE & FALSE to how
| it is evaluated.

> FALSE & FALSE
[1] FALSE

| Great job!

  |                                                                              |===========================                                           |  38%
| You can use the `&` operator to evaluate AND across a vector. The `&&`
| version of AND only evaluates the first member of a vector. Let's test both
| for practice. Type the expression TRUE & c(TRUE, FALSE, FALSE).

> TRUE & c(TRUE, FALSE, FALSE)
[1]  TRUE FALSE FALSE

| You are amazing!

  |                                                                              |============================                                          |  40%
| What happens in this case is that the left operand `TRUE` is recycled across
| every element in the vector of the right operand. This is the equivalent
| statement as c(TRUE, TRUE, TRUE) & c(TRUE, FALSE, FALSE).

...

  |                                                                              |==============================                                        |  42%
| Now we'll type the same expression except we'll use the `&&` operator. Type
| the expression TRUE && c(TRUE, FALSE, FALSE).

> TRUE && c(TRUE, FALSE, FALSE)
[1] TRUE

| You got it!

  |                                                                              |===============================                                       |  44%
| In this case, the left operand is only evaluated with the first member of the
| right operand (the vector). The rest of the elements in the vector aren't
| evaluated at all in this expression.

...

  |                                                                              |================================                                      |  46%
| The OR operator follows a similar set of rules. The `|` version of OR
| evaluates OR across an entire vector, while the `||` version of OR only
| evaluates the first member of a vector.

...

  |                                                                              |==================================                                    |  48%
| An expression using the OR operator will evaluate to TRUE if the left operand
| or the right operand is TRUE. If both are TRUE, the expression will evaluate
| to TRUE, however if neither are TRUE, then the expression will be FALSE.

...

  |                                                                              |===================================                                   |  50%
| Let's test out the vectorized version of the OR operator. Type the expression
| TRUE | c(TRUE, FALSE, FALSE).

> TRUE | c(TRUE, FALSE, FALSE)
[1] TRUE TRUE TRUE

| You are quite good my friend!

  |                                                                              |====================================                                  |  52%
| Now let's try out the non-vectorized version of the OR operator. Type the
| expression TRUE || c(TRUE, FALSE, FALSE).

> TRUE || c(TRUE, FALSE, FALSE)
[1] TRUE

| Nice work!

  |                                                                              |======================================                                |  54%
| Logical operators can be chained together just like arithmetic operators. The
| expressions: `6 != 10 && FALSE && 1 >= 2` or `TRUE || 5 < 9.3 || FALSE` are
| perfectly normal to see.

...

  |                                                                              |=======================================                               |  56%
| As you may recall, arithmetic has an order of operations and so do logical
| expressions. All AND operators are evaluated before OR operators. Let's look
| at an example of an ambiguous case. Type: 5 > 8 || 6 != 8 && 4 > 3.9

> 5 > 8 || 6 != 8 && 4 > 3.9
[1] TRUE

| Your dedication is inspiring!

  |                                                                              |========================================                              |  58%
| Let's walk through the order of operations in the above case. First the left
| and right operands of the AND operator are evaluated. 6 is not equal 8, 4 is
| greater than 3.9, therefore both operands are TRUE so the resulting
| expression `TRUE && TRUE` evaluates to TRUE. Then the left operand of the OR
| operator is evaluated: 5 is not greater than 8 so the entire expression is
| reduced to FALSE || TRUE. Since the right operand of this expression is TRUE
| the entire expression evaluates to TRUE.

...

  |                                                                              |==========================================                            |  60%
| Which one of the following expressions evaluates to TRUE?

1: TRUE && 62 < 62 && 44 >= 44
2: FALSE || TRUE && FALSE
3: TRUE && FALSE || 9 >= 4 && 3 < 6
4: 99.99 > 100 || 45 < 7.3 || 4 != 4.0

Selection: 3

| Keep up the great work!

  |                                                                              |===========================================                           |  62%
| Which one of the following expressions evaluates to FALSE?

1: 6 >= -9 && !(6 > 7) && !(!TRUE)
2: !(8 > 4) ||  5 == 5.0 && 7.8 >= 7.79
3: FALSE || TRUE && 6 != 4 || 9 > 4
4: FALSE && 6 >= 6 || 7 >= 8 || 50 <= 49.5

Selection: 4

| You are amazing!

  |                                                                              |============================================                          |  63%
| Now that you're familiar with R's logical operators you can take advantage of
| a few functions that R provides for dealing with logical expressions.

...

  |                                                                              |==============================================                        |  65%
| The function isTRUE() takes one argument. If that argument evaluates to TRUE,
| the function will return TRUE. Otherwise, the function will return FALSE. Try
| using this function by typing: isTRUE(6 > 4)

> isTRUE(6 > 4)
[1] TRUE

| You nailed it! Good job!

  |                                                                              |===============================================                       |  67%
| Which of the following evaluates to TRUE?

1: isTRUE(NA)
2: !isTRUE(4 < 3)
3: !isTRUE(8 != 5)
4: isTRUE(3)
5: isTRUE(!TRUE)

Selection: 2

| Excellent work!

  |                                                                              |================================================                      |  69%
| The function identical() will return TRUE if the two R objects passed to it
| as arguments are identical. Try out the identical() function by typing:
| identical('twins', 'twins')

> identical ("twins", "Twins")

> identical ("twins", "twins") 
[1] TRUE

| Excellent job!

  |                                                                              |==================================================                    |  71%
| Which of the following evaluates to TRUE?

1: identical(4, 3.1)
2: identical('hello', 'Hello')
3: identical(5 > 4, 3 < 3.1)
4: !identical(7, 7)

Selection: 3

| You are doing so well!

  |                                                                              |===================================================                   |  73%
| You should also be aware of the xor() function, which takes two arguments.
| The xor() function stands for exclusive OR. If one argument evaluates to TRUE
| and one argument evaluates to FALSE, then this function will return TRUE,
| otherwise it will return FALSE. Try out the xor() function by typing: xor(5
| == 6, !FALSE)

> xor(5 == 6, !FALSE)
[1] TRUE

| All that practice is paying off!

  |                                                                              |====================================================                  |  75%
| 5 == 6 evaluates to FALSE, !FALSE evaluates to TRUE, so xor(FALSE, TRUE)
| evaluates to TRUE. On the other hand if the first argument was changed to 5
| == 5 and the second argument was unchanged then both arguments would have
| been TRUE, so xor(TRUE, TRUE) would have evaluated to FALSE.

...

  |                                                                              |======================================================                |  77%
| Which of the following evaluates to FALSE?

1: xor(!isTRUE(TRUE), 6 > -1)
2: xor(!!TRUE, !!FALSE)
3: xor(identical(xor, 'xor'), 7 == 7.0)
4: xor(4 >= 9, 8 != 8.0)

Selection: 4

| You nailed it! Good job!

  |                                                                              |=======================================================               |  79%
| For the next few questions, we're going to need to create a vector of
| integers called ints. Create this vector by typing: ints <- sample(10)

> ints <- sample (10)

| You're the best!

  |                                                                              |=========================================================             |  81%
| Now simply display the contents of ints.

> ints
 [1]  5  9  7  1  3 10  4  2  8  6

| You nailed it! Good job!

  |                                                                              |==========================================================            |  83%
| The vector `ints` is a random sampling of integers from 1 to 10 without
| replacement. Let's say we wanted to ask some logical questions about contents
| of ints. If we type ints > 5, we will get a logical vector corresponding to
| whether each element of ints is greater than 5. Try typing: ints > 5

> ints > 5
 [1] FALSE  TRUE  TRUE FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE

| You got it!

  |                                                                              |===========================================================           |  85%
| We can use the resulting logical vector to ask other questions about ints.
| The which() function takes a logical vector as an argument and returns the
| indices of the vector that are TRUE. For example which(c(TRUE, FALSE, TRUE))
| would return the vector c(1, 3).

...

  |                                                                              |=============================================================         |  87%
| Use the which() function to find the indices of ints that are greater than 7.

> which(ints < 7)
[1]  1  4  5  7  8 10

| Nice try, but that's not exactly what I was hoping for. Try again. Or, type
| info() for more options.

| Use the which() function on the logical vector produced by: `ints > 7`

> which(ints > 7)
[1] 2 6 9

| Your dedication is inspiring!

  |                                                                              |==============================================================        |  88%
| Which of the following commands would produce the indices of the elements in
| ints that are less than or equal to 2?

1: which(ints < 2)
2: which(ints <= 2)
3: ints <= 2
4: ints < 2

Selection: which(ints <= 2)

| Keep up the great work!

  |                                                                              |===============================================================       |  90%
| Like the which() function, the functions any() and all() take logical vectors
| as their argument. The any() function will return TRUE if one or more of the
| elements in the logical vector is TRUE. The all() function will return TRUE
| if every element in the logical vector is TRUE.

...

  |                                                                              |=================================================================     |  92%
| Use the any() function to see if any of the elements of ints are less than
| zero.

> any (ints)
[1] TRUE

| Not quite! Try again. Or, type info() for more options.

| Use the any() function on the logical vector produced by: `ints < 0`

> any (ints < 0)
[1] FALSE

| You are amazing!

  |                                                                              |==================================================================    |  94%
| Use the all() function to see if all of the elements of ints are greater than
| zero.

> all(ints < 0)
[1] FALSE

| You're close...I can feel it! Try it again. Or, type info() for more options.

| Use the all() function on the logical vector produced by: `ints > 0`

> all(ints > 0)
[1] TRUE

| That's the answer I was looking for.

  |                                                                              |===================================================================   |  96%
| Which of the following evaluates to TRUE?

1: any(ints == 10)
2: all(c(TRUE, FALSE, TRUE))
3: all(ints == 10)
4: any(ints == 2.5)

Selection: any(ints == 2.5)

| Not quite, but you're learning! Try again.

| any() will evaluate to TRUE if there is one or more TRUE elements in a
| logical vector.

1: all(c(TRUE, FALSE, TRUE))
2: all(ints == 10)
3: any(ints == 10)
4: any(ints == 2.5)

Selection: 3

| Keep working like that and you'll get there!

  |                                                                              |===================================================================== |  98%
| That's all for this introduction to logic in R. If you really want to see
| what you can do with logic, check out the control flow lesson!

...

  |                                                                              |======================================================================| 100%
| Would you like to receive credit for completing this course on Coursera.org?

1: No
2: Yes

Selection: 1

| That's the answer I was looking for.

| You've reached the end of this lesson! Returning to the main menu...

| Please choose a course, or type 0 to exit swirl.

1: R Programming
2: Take me to the swirl course repository!

Selection: 
